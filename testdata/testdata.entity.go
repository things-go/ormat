// Code generated by ormat. DO NOT EDIT.
// version: v0.9.6-rc1

package testdata

import (
	"gorm.io/gorm"
)

type TestData1_Entity struct {
	db *gorm.DB
}

type TestData1_Executor struct {
	db    *gorm.DB
	funcs []func(*gorm.DB) *gorm.DB
}

func New_TestData1(db *gorm.DB) *TestData1_Entity {
	return &TestData1_Entity{
		db: db,
	}
}

// PreProcess on db
func (x *TestData1_Entity) PreProcess(funcs ...func(*gorm.DB) *gorm.DB) *TestData1_Executor {
	db := x.db
	for _, f := range funcs {
		db = f(db)
	}
	return &TestData1_Executor{
		db:    db,
		funcs: make([]func(*gorm.DB) *gorm.DB, 0, 16),
	}
}

// Condition additional condition to executor
func (x *TestData1_Entity) Condition(funcs ...func(*gorm.DB) *gorm.DB) *TestData1_Executor {
	return &TestData1_Executor{
		db:    x.db,
		funcs: funcs,
	}
}

// Condition additional condition
func (x *TestData1_Executor) Condition(funcs ...func(*gorm.DB) *gorm.DB) *TestData1_Executor {
	x.funcs = append(x.funcs, funcs...)
	return x
}

func (x *TestData1_Executor) FirstOne() (*TestData1, error) {
	var row TestData1

	err := x.First(&row)
	if err != nil {
		return nil, err
	}
	return &row, nil
}

func (x *TestData1_Executor) TakeOne() (*TestData1, error) {
	var row TestData1

	err := x.Take(&row)
	if err != nil {
		return nil, err
	}
	return &row, nil
}

func (x *TestData1_Executor) LastOne(query any) (*TestData1, error) {
	var row TestData1

	err := x.Last(&row)
	if err != nil {
		return nil, err
	}
	return &row, nil
}

func (x *TestData1_Executor) ScanOne() (*TestData1, error) {
	var row TestData1

	err := x.Scan(&row)
	if err != nil {
		return nil, err
	}
	return &row, nil
}

func (x *TestData1_Executor) First(dest any) error {
	return x.db.Model(&TestData1{}).
		Scopes(x.funcs...).
		First(dest).Error
}

func (x *TestData1_Executor) Take(dest any) error {
	return x.db.Model(&TestData1{}).
		Scopes(x.funcs...).
		Take(dest).Error
}

func (x *TestData1_Executor) Last(dest any) error {
	return x.db.Model(&TestData1{}).
		Scopes(x.funcs...).
		Last(dest).Error
}

func (x *TestData1_Executor) Scan(dest any) error {
	return x.db.Model(&TestData1{}).
		Scopes(x.funcs...).
		Scan(dest).Error
}

func (x *TestData1_Executor) Pluck(column string, value any) error {
	return x.db.Model(&TestData1{}).
		Scopes(x.funcs...).
		Pluck(column, value).Error
}

func (x *TestData1_Executor) Exist() (exist bool, err error) {
	err = x.db.Model(&TestData1{}).
		Select("1").
		Scopes(x.funcs...).
		Limit(1).
		Scan(&exist).Error
	return exist, err
}

func (x *TestData1_Executor) FindAll() ([]*TestData1, error) {
	var rows []*TestData1

	err := x.Find(&rows)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

func (x *TestData1_Executor) Find(dest any) error {
	return x.db.Model(&TestData1{}).
		Scopes(x.funcs...).
		Find(dest).Error
}

func (x *TestData1_Executor) Create(value any) error {
	return x.db.Scopes(x.funcs...).Create(value).Error
}

func (x *TestData1_Executor) CreateInBatches(value any, batchSize int) error {
	return x.db.Scopes(x.funcs...).CreateInBatches(value, batchSize).Error
}

func (x *TestData1_Executor) Save(value any) error {
	return x.db.Model(&TestData1{}).
		Scopes(x.funcs...).
		Save(value).Error
}

func (x *TestData1_Executor) Updates(value *TestData1) error {
	return x.db.Model(&TestData1{}).
		Scopes(x.funcs...).
		Updates(value).Error
}

func (x *TestData1_Executor) Update(column string, value any) error {
	return x.db.Model(&TestData1{}).
		Scopes(x.funcs...).
		Update(column, value).Error
}

func (x *TestData1_Executor) UpdateColumns(value *TestData1) error {
	return x.db.Model(&TestData1{}).
		Scopes(x.funcs...).
		UpdateColumns(value).Error
}

func (x *TestData1_Executor) UpdateColumn(column string, value any) error {
	return x.db.Model(&TestData1{}).
		Scopes(x.funcs...).
		UpdateColumn(column, value).Error
}

func (x *TestData1_Executor) Delete() error {
	return x.db.Model(&TestData1{}).
		Scopes(x.funcs...).
		Delete(&TestData1{}).Error
}

type TestData2_Entity struct {
	db *gorm.DB
}

type TestData2_Executor struct {
	db    *gorm.DB
	funcs []func(*gorm.DB) *gorm.DB
}

func New_TestData2(db *gorm.DB) *TestData2_Entity {
	return &TestData2_Entity{
		db: db,
	}
}

// PreProcess on db
func (x *TestData2_Entity) PreProcess(funcs ...func(*gorm.DB) *gorm.DB) *TestData2_Executor {
	db := x.db
	for _, f := range funcs {
		db = f(db)
	}
	return &TestData2_Executor{
		db:    db,
		funcs: make([]func(*gorm.DB) *gorm.DB, 0, 16),
	}
}

// Condition additional condition to executor
func (x *TestData2_Entity) Condition(funcs ...func(*gorm.DB) *gorm.DB) *TestData2_Executor {
	return &TestData2_Executor{
		db:    x.db,
		funcs: funcs,
	}
}

// Condition additional condition
func (x *TestData2_Executor) Condition(funcs ...func(*gorm.DB) *gorm.DB) *TestData2_Executor {
	x.funcs = append(x.funcs, funcs...)
	return x
}

func (x *TestData2_Executor) FirstOne() (*TestData2, error) {
	var row TestData2

	err := x.First(&row)
	if err != nil {
		return nil, err
	}
	return &row, nil
}

func (x *TestData2_Executor) TakeOne() (*TestData2, error) {
	var row TestData2

	err := x.Take(&row)
	if err != nil {
		return nil, err
	}
	return &row, nil
}

func (x *TestData2_Executor) LastOne(query any) (*TestData2, error) {
	var row TestData2

	err := x.Last(&row)
	if err != nil {
		return nil, err
	}
	return &row, nil
}

func (x *TestData2_Executor) ScanOne() (*TestData2, error) {
	var row TestData2

	err := x.Scan(&row)
	if err != nil {
		return nil, err
	}
	return &row, nil
}

func (x *TestData2_Executor) First(dest any) error {
	return x.db.Model(&TestData2{}).
		Scopes(x.funcs...).
		First(dest).Error
}

func (x *TestData2_Executor) Take(dest any) error {
	return x.db.Model(&TestData2{}).
		Scopes(x.funcs...).
		Take(dest).Error
}

func (x *TestData2_Executor) Last(dest any) error {
	return x.db.Model(&TestData2{}).
		Scopes(x.funcs...).
		Last(dest).Error
}

func (x *TestData2_Executor) Scan(dest any) error {
	return x.db.Model(&TestData2{}).
		Scopes(x.funcs...).
		Scan(dest).Error
}

func (x *TestData2_Executor) Pluck(column string, value any) error {
	return x.db.Model(&TestData2{}).
		Scopes(x.funcs...).
		Pluck(column, value).Error
}

func (x *TestData2_Executor) Exist() (exist bool, err error) {
	err = x.db.Model(&TestData2{}).
		Select("1").
		Scopes(x.funcs...).
		Limit(1).
		Scan(&exist).Error
	return exist, err
}

func (x *TestData2_Executor) FindAll() ([]*TestData2, error) {
	var rows []*TestData2

	err := x.Find(&rows)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

func (x *TestData2_Executor) Find(dest any) error {
	return x.db.Model(&TestData2{}).
		Scopes(x.funcs...).
		Find(dest).Error
}

func (x *TestData2_Executor) Create(value any) error {
	return x.db.Scopes(x.funcs...).Create(value).Error
}

func (x *TestData2_Executor) CreateInBatches(value any, batchSize int) error {
	return x.db.Scopes(x.funcs...).CreateInBatches(value, batchSize).Error
}

func (x *TestData2_Executor) Save(value any) error {
	return x.db.Model(&TestData2{}).
		Scopes(x.funcs...).
		Save(value).Error
}

func (x *TestData2_Executor) Updates(value *TestData2) error {
	return x.db.Model(&TestData2{}).
		Scopes(x.funcs...).
		Updates(value).Error
}

func (x *TestData2_Executor) Update(column string, value any) error {
	return x.db.Model(&TestData2{}).
		Scopes(x.funcs...).
		Update(column, value).Error
}

func (x *TestData2_Executor) UpdateColumns(value *TestData2) error {
	return x.db.Model(&TestData2{}).
		Scopes(x.funcs...).
		UpdateColumns(value).Error
}

func (x *TestData2_Executor) UpdateColumn(column string, value any) error {
	return x.db.Model(&TestData2{}).
		Scopes(x.funcs...).
		UpdateColumn(column, value).Error
}

func (x *TestData2_Executor) Delete() error {
	return x.db.Model(&TestData2{}).
		Scopes(x.funcs...).
		Delete(&TestData2{}).Error
}
